
Js code execute inside browser (using js engine which is present only in browser)
executinh js code outside browser was not possible

chrome -> v8 engine
firefox -> spider monkey

v8 engine embedded with c++ => node.js

# Node.js (Runtime environment for js)

1) we can run js outside of the browser
2) js can talk to native machine because of c++
3) we can create webserver in js language

window objects is not present with node.js (like alert() etc..)

...............................................................

# Modules

split files into smaller code

build in modules -> http, fs, os, crypto, url

const url = require("url")

const myUrl = url.parse(req.url)
..........................................


How node.js works

request -> event queue -> event loop (it watches event queue and take request from it) -> 
if(request is non blocking (Async)) it will return response
else if (request is blocking (Sync)) it will tell thread pool that it need worker/thread to complete the work
   then return request


.....................................................................

http methods

Get -> when want to send some data from server
Post -> Submit data to server
Put -> Update resource or create it if it doesn't exist.
Patch -> Apply partial modifications to a resource.
Delete -> Request removal of resource.

.............................................................

Express :- node js framework

in node.js we handle everything from scratch

..............................
Versioning

example :- 18.2.1
1 :- Minor fixes (Uptional update)
2 :- Recommended bug fix (or feature added)
18 :- Mojor release/ can break existing code


^version :- compatible with version  (update ony minor and recommended , not major release)
~version :- only update minor fixes

...................................................

SSR => server side rendering -> render at server and send to rendered data to client (fast and secure)
CSR => client side rendering -> send data like in JSON then client read json data & render on screen

....................................................

Middleware

Middleware functions can perform the following tasks:

Execute any code.
Make changes to the request and the response objects.
End the request-response cycle.
Call the next middleware function in the stack.

....................................................

http headers are an imp part of the API request and response as they represent the meta-data
associate with the API request and response.

headers carry information for the request and response body

....................................................

Status code

Informational responses (100 – 199)
Successful responses (200 – 299)
Redirection messages (300 – 399)
Client error responses (400 – 499)
Server error responses (500 – 599)

200 -> request succeeded
201 -> created
204 -> There is no content to send for this request, but the headers may be useful
400 -> bad request (client error)
401 -> unauthorized
403 -> does not have access rights
404 -> server cannot find the requested resource
500 -> (Internal server error) he server has encountered a situation it does not know how to handle.
501 -> Not Implemented
504 -> Gateway Timeout (cannot get a response in time)

...................................

MongoDb

No-Sql document based db 
works on BSON format

.....................................

Server side rendering

web page render from server

templating engines
EJS :- embedded javascript templating
Pug js
handlebar

ejs code
    <!-- <% urls.forEach(url => { %>
        <li> <%= url.shortId %></li>
   <%
    })%> -->

......................................

Authentication

Auth patterns
1) Statefull :- Which maintains state or data on server side
example :- if i give username and password to server it will give me sesson uid, user with that uid can request to server
if user request to server with that uid , server will check who is user with that specific id and if valid then return the response

How to tranfer uid :- cookies, response, headers

users logged out if we restart server
it's memory intensive (server have Limited memory )

client -> Auth meddleware (checks for cookies values or uid , if valid calls next(), else reject the request) -> endpoint route

2) Stateless :- Which has no state

uuid :- generate session id

..................................................

server creates JWT token , but how server send this to client in secure way?
1) cookies -> res.cookie...
  server creates cookie..
  browsers store cookie and send to server when client request something from server (default behavior of browser)

  cookies are domain specific,
  we can set parameters -> domain, expire....etc

  domain -> .google.com -> if we logged in gmail, and when we open youtube it will automatically open with same email id
      (using same cookie for .google.com domain)

2) response

server will create token 
 res.json({token})
 now it's user responsibility to user this token

 but how to get this token from server?

// one way
 header : {
    Token : token
 }

 // standard way
 header : {
    Authentication: "Beaer <token>"
 }

 in code

 res.cookie("uid", token) --> return res.json({token})

 in middleware
  userid = req.header?['authentication']

  token = userid.split('Bearer')[1]

  ............................................

  Authentication :- User belongs to that particular application
  Authorization :- checking for a particular resouce are you authorize to access that?
  
  ........................................................

  package :- express status monitor

  ....................................................

  Streams in node.js

  read chunk by chunk and send chunks in response , don't wait to load complete data and store in memory.

  app.get('/', (req,res) => {
    const stream = fs.createReadStream("file-name", "utf-8");
    stream.on("data", (chunk) => res.write(chunk));
    stream.on("end", () => res.end())
  })

  in header -> Transfer-encoding : chunked

  zlib package :- to zip file

  // stream Read (Sample.txt) --> zipper --> fs write stream (pipeline)

  fs.createReadStream("./sample.txt").pipe(zlib.createGzip().pipe(fs.createWriteStream("./sample.zip)))

  // read node.js stream documentation

  